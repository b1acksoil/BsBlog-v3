[{"content":"最近终于接触了大名鼎鼎的 LeetCode 刷题平台，开始苦痛之路（x\nLeetCode 自带的网页编辑器体验并不好，代码补全、高亮等都不是很舒服，于是打算使用本地开发。尝试在 Rider 中找到了 IntelliJ 平台通用的 LeetCode 插件，但是对于 C# 支持并不是很好，有些水土不服，而且 Rider 也不很适合单个文件开发。最后我找到了 VSCode 的一款 LeetCode 刷题扩展，基本符合了我的需求。\n这篇文章将简单记录一下结合 .NET / C# 使用的过程。\n准备工作 首先安装 Visual Studio Code。 打开 VSCode，在左侧的扩展市场找到以下扩展并安装： C# by Microsoft：基于 OmniSharp 提供对 C# 的语言支持，包括自动补全、语法高亮等。 LeetCode by 力扣 LeetCode：LeetCode 官方提供的刷题扩展，拥有题库查看、测试、提交等功能。扩展的中文文档 配置 LeetCode 扩展和 .NET 新建一个文件夹并在 VSCode 中打开，这将作为我们 LeetCode 的工作区。\n在左侧找到 LeetCode 图标打开侧边栏，首先点击上方的小地球标志切换为国内的站点（leetcode.cn），然后点击 Sign in to LeetCode，输入账号密码登录。加载好后侧边栏会显示账号目前可用的题库。\n随便打开一道，点击页面右下角的 Code Now 按钮，提示选择使用的语言，这里选择 csharp (C#)，扩展会自动创建一个名为 ID.题目名称.cs 的文件，例如下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* * @lc app=leetcode.cn id=1 lang=csharp * * [1] 两数之和 */ // @lc code=start public class Solution { public int[] TwoSum(int[] nums, int target) { } } // @lc code=end 这个文件中，最上方的一块注释包含了题目的ID、标题，和用于 LeetCode 扩展识别的题目元数据。然后是两行特殊的注释，// @lc code=start 和 // @lc code=end。这两行中间的所有内容都会作为提交或测试题目时的提交内容，就像是网页编辑器中一样。而这两行之外的内容都不会提交，因此可以写一些本地测试用代码。\n我们发现自动生成的文件直接放在根目录下，而且没有文件夹分隔。这样会显得很杂乱——尤其是需要为一道题编写多个题解的时候。LeetCode 扩展提供了一系列组件帮助我们自定义文件的生成路径。\n打开设置页面，搜索 leetcode 并找到 Leetcode: Workspace Folder 设置项，将值更改为 LeetCode 工作区的目录。这一项指定了 LeetCode 文件生成的相对目录。\n然后找到 LeetCode: File Path 项，点击进入 settings.json 中编辑。VSCode 会自动生成一些默认配置，我们对照修改即可：\n1 2 3 4 5 6 \u0026#34;leetcode.filePath\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;folder\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;${id}-${kebab-case-name}.${ext}\u0026#34; } } 修改 folder 和 filename 的值，其中 folder 的值将作为文件目录名的模板（相对于工作区根目录），filename 的值将作为生成文件名的模板。可以使用 ${xxx} 作为预定义的插值，可以查看官方文档了解可使用的插值。\n我根据个人习惯修改成了如下形式：\n1 2 3 4 5 6 \u0026#34;leetcode.filePath\u0026#34;: { \u0026#34;default\u0026#34;: { \u0026#34;folder\u0026#34;: \u0026#34;src/${id}-${PascalCaseName}\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;Solution-.${ext}\u0026#34; } } 这样生成的文件路径会形如 src/1-两数之和/Solution-.cs。\n关于命名 这里我在 Solution 后加了一个横杠，方便有多个题解的同时存在。只需重命名并在 - 后面加上序号即可，例如 Solution-1.cs Solution-2.cs。 文件生成好了，但我们还不能正式开始编写代码。不信试试，你会发现除了少数几个关键字外根本没有代码提示\u0026hellip;\n其实解决办法很简单，我们只需要在项目里创建一个 csproj 文件，将工作区内的 cs 文件表示成一个项目就可以了（一个 .csproj 就可以，不用带上解决方案 .sln 文件）。\ncsproj 文件的存放位置 这里我将 LeetCode.csproj 放在了 src 目录下。由于 csproj 文件的位置会影响到 bin、obj 文件夹的位置，所以你的位置如果不一样，记得同步更改后文的 launch.json。 以下是基本的内容：\n1 2 3 4 5 6 7 8 9 \u0026lt;!-- LeetCode.csproj --\u0026gt; \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt; 目前观察下来 LeetCode 在执行 C# 代码时是会带上 ImplictUsings 的，所以这里我们也带上，减少麻烦。同时根据官网说明，LeetCode 使用的是 .NET 6，因此我们指定 TargetFramework 为 net6.0。\n创建完项目文件后重启 VSCode，让 OmniSharp 服务重新加载一下。此时再编写代码就会有代码提示了。\n报了几十个莫名其妙的错误？ 如果遇到诸如无法识别 System 命名空间等奇葩问题，可以删除生成的 bin 和 obj 文件夹，然后重新手动执行 dotnet restore。 调试配置 有时我们通不过测试，但又不知道哪里出现了问题，这时我们就可以对程序 debug。得益于 VSCode 高度自定义化的调试配置，即使是 LeetCode 题解这样奇怪的项目结构也是可以调试的。\n由于每个文件都是一个题解，常规的 .NET 调试方法并不适用，而所有题解共用一个入口点就过于麻烦了。这里采用的方法是将题解分隔至不同的命名空间，并在调试编译时指定 StartupObject 来指定启动的 Main 方法，从而执行单个题解的调试。\n首先我们在刚刚生成的 cs 文件顶端添加一行 namespace LeetCode.P1.S1;。这是我个人的命名方法，代表 1 号题目 (Problem) 的第 1 个题解 (Solution)。你也可以修改成自己的样式，注意同时需要在后文的 tasks.json 中同步更改。\n在工作区根目录新建 .vscode 文件夹，并在其中新建以下文件和内容：\n.vscode/tasks.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;dotnet\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;process\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;build\u0026#34;, \u0026#34;${workspaceFolder}/src/LeetCode.csproj\u0026#34;, \u0026#34;-p:StartupObject=LeetCode.P${input:problem}.S${input:solution}.Program\u0026#34;, \u0026#34;-p:GenerateFullPaths=true\u0026#34;, \u0026#34;/consoleloggerparameters:NoSummary\u0026#34; ], \u0026#34;problemMatcher\u0026#34;: \u0026#34;$msCompile\u0026#34; } ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;problem\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Please enter the problem ID.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;solution\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Please enter the solution number.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34; } ] } 在 dotnet build 的选项中，我们指定了 -p:StartupObject=LeetCode.P${input:problem}.S${input:solution}.Program。这采用了 VSCode 的配置语法，执行该 task 时，VSCode 会展示两个输入框，一个是题目ID，一个是题解ID。例如用户输入 123、1 后会拼接成 -p:StartupObject=LeetCode.P123.S1.Program。选项意味着将程序的入口点设置为 LeetCode.P123.S1.Program 中的 Main 方法。\n底下的 inputs 块是对上面两个输入框数据的描述。\n然后我们创建 .vscode/launch.json 文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;.NET Core Launch (console)\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;coreclr\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/src/bin/Debug/net6.0/LeetCode.dll\u0026#34;, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;internalConsole\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false } ] } 这个文件由 VSCode 自动生成的修改而来，只动了 program 项，将其指定为编译后的 DLL 文件路径。\n在题解文件中，// @lc code=end 行下方（这样就不会把测试代码提交至 LeetCode）添加一个 Program 类，并添加一个 Main 静态方法，在其中实例化 Solution 类并调用题目方法。整个文件如下（以题目 9.回文数 举例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* * @lc app=leetcode.cn id=9 lang=csharp * * [9] 回文数 */ // 指定命名空间 namespace LeetCode.P9.S1; // 以下内容会被提交至 LeetCode // @lc code=start public class Solution { public bool IsPalindrome(int x) { // 题解代码... // 你可以在任意地方打上断点调试。 return true; } } // @lc code=end // 以上内容会被提交至 LeetCode public static class Program { // 程序从这里开始 public static void Main() { // 实例化 Solution 类 var solution = new Solution(); // 调用方法，进入调试 solution.IsPalindrome(1000021); } } 按 F5 开启调试，提示输入题目 ID ( 9 ) 和题解序号 ( 1 )，随后成功启动调试。\n一些小技巧 对于测试，每次手动输入 namespace 和 Program 之类的东西还是有点麻烦。我们可以编写一些 code snippets 来达到自动补全的效果。\n新建 .vscode/csharp.code-snippets 文件，输入以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;SolutionNamespace\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;csharp\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;ns\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;namespace LeetCode.P$1.S$2;\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Solution Namespace\u0026#34; }, \u0026#34;TestProgram\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;csharp\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;tp\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;public static class Program\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34; public static void Main()\u0026#34;, \u0026#34; {\u0026#34;, \u0026#34; var solution = new Solution();\u0026#34;, \u0026#34; \u0026#34;, \u0026#34; $1\u0026#34;, \u0026#34; }\u0026#34;, \u0026#34;}\u0026#34; ], \u0026#34;description\u0026#34;: \u0026#34;Test Program\u0026#34; } } 这样输入 ns 并 Tab 就能自动补全命名空间，输入 tp 就能自动补全测试类。\n","date":"2022-11-20T20:51:55+08:00","permalink":"https://sorabs.cc/posts/vscode-leetcode-with-csharp/","title":"使用 VSCode 打造 LeetCode 的 C# 刷题环境"},{"content":"给树莓派重新装了系统，重新把自己的 bot 挂上去，发现生成图片的时候会报出奇怪的错误：\n1 2 3 TypeInitializationException: The type initializer for \u0026#39;SkiaSharp.SKImageInfo\u0026#39; threw an exception. at SkiaSharp.SKImageInfo..ctor(Int32 width, Int32 height) ... 查询一番后，大多都是说是 SkiaSharp 的版本问题，升级就好，但是我已经在使用最新版本了）最后在这里找到了解决方案。\n报错的原因是：系统缺少了 libfontconfig，导致字体相关操作无法完成。\n那就很简单了，使用 yay 找找相关的包：\n1 2 3 4 5 6 7 8 $ yay libfontconfig 2 extra/libfontenc 1.1.6-1 (14.2 KiB 35.3 KiB) X11 font encoding library 1 extra/fontconfig 2:2.14.0-1 (340.5 KiB 1.0 MiB) Library for configuring and customizing font access ==\u0026gt; 要安装的包 (示例: 1 2 3, 1-3 或 ^4) ==\u0026gt; 1 看来就是这个 extra/fontconfig 了，安装上去，重启应用再试了试，生成图片一切正常了。\n","date":"2022-10-02T14:46:48+08:00","permalink":"https://sorabs.cc/posts/skiasharp-type-initializer-exception/","title":"SkiaSharp 的 Type Initializer Exception 解决记录"},{"content":"前言 自从在虚拟机、WSL2 上相继安装过 Arch Linux 之后，我将目光投向了家里仅剩的一个还运行着 Ubuntu 的 Linux 设备 —— 树莓派 4B。\n话不多说，直接开搞（\n准备 首先由于启动方式的不同，Arch Linux ARM for Raspberry Pi 并不能使用我们一般用的 RPi Imager 烧录。要安装 Arch，首先得准备一台已经装好了的 Linux 设备。可以使用虚拟机，这里我直接用树莓派的备用系统（一张烧好了官方系统的 SD 卡，作为后备还原系统）安装。\n随便 pick 一张适合做系统的 SD 卡插入电脑，开始我们的安装。\n安装 使用 lsblk 命令查看连接到设备的 SD 卡设备号，我这里为 /dev/sda。\n确认无误后，使用 sudo fdisk /dev/sda （之后的 /dev/sda 都换成你的 SD 卡）开始分区。\n步骤如下：\n输入 o，清除 SD 卡上现有的所有分区 输入 n，新建一个分区，输入 1 代表创建设备上的第一个分区，直接回车使用默认起始位置，然后输入 +200M 指定结束位置。 输入 t，然后输入 c，将刚刚创建的分区类型切换为 W95 FAT32 (LBA)。 输入 n，再新建一个分区，输入 2，代表创建设备上的第二个分区，回车两次使用默认的起始和结束位置。 输入 w，将刚刚的改动写入 SD 卡。 格式化新创建的分区：\n1 2 $ mkfs.vfat /dev/sda1 $ mkfs.ext4 /dev/sda2 挂载分区：\n1 2 3 $ mkdir boot root $ mount /dev/sda1 boot $ mount /dev/sda2 root 下载 rootfs 包，并将其解压到 root 目录下：\n1 2 3 $ wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-aarch64-latest.tar.gz $ bsdtar -xpf ArchLinuxARM-rpi-armv7-latest.tar.gz -C root $ sync 下载太慢... 如果下载太慢，也可以使用国内源下载，将 url 换为 https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-rpi-aarch64-latest.tar.gz 将启动文件复制到 boot 目录下：\n1 $ mv root/boot/* boot 更新 fstab：\n1 $ sed -i \u0026#39;s/mmcblk0/mmcblk1/g\u0026#39; root/etc/fstab 卸载 SD 卡：\n1 $ umount boot root 接下来把 SD 卡插入树莓派，连上网线，在路由器查看树莓派的 IP 地址，然后使用 SSH 链接。默认用户名称和密码都为 alarm。登录上后切换到 root 用户（默认密码为 root），编辑 /etc/pacman.d/mirrorlist 换源：\n1 2 $ su root # nano /etc/pacman.d/mirrorlist 在文件开头添加以下内容：\n1 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/$arch/$repo 也可以自行寻找其他的源添加，Ctrl+X 保存退出。\n接着初始化 pacman 密钥：\n1 2 # pacman-key --init # pacman-key --populate archlinuxarm 安装基本包：\n1 # pacman -Syyu base-devel git 然后就完成了 Arch Linux ARM 在树莓派上的安装，接下来照例安装一下基本环境。\n配置（可选） 默认用户名字叫 alarm，不太好听，改个自己的（bs 换成用户名）：\n1 # useradd -m -g users -G wheel -s /bin/bash bs 安装 yay 包管理器\n1 2 3 4 $ cd ~ $ git clone https://aur.archlinux.org/yay-bin.git $ cd yay-bin $ makepkg -si 基本软件包\n1 $ yay -S vim tree neofetch 安装 oh-my-zsh\n1 2 $ yay -S zsh curl $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 常用 zsh 插件\n1 2 3 $ cd ~/.oh-my-zsh/plugins/ $ git clone https://github.com/zsh-users/zsh-autosuggestions.git --depth 1 $ git clone https://github.com/zsh-users/zsh-syntax-higlighting.git --depth 1 编辑 ~/.zshrc，修改 plugins 项\n1 2 3 4 5 plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 连接 WiFi 我们目前还是通过有线网连接到的网络，可以使用 NetworkManager 连接到 WiFi：\n1 2 3 $ yay -S networkmanager $ sudo systemctl enable NetworkManager $ sudo systemctl start NetworkManager 显示附近的 WiFi：\n1 $ nmcli device wifi list 连接 WiFi：\n1 $ nmcli device wifi connect WiFi名称 password 密码 使用 ip addr 查看，发现已经连接到 WiFi了。\n","date":"2022-10-02T10:51:14+08:00","permalink":"https://sorabs.cc/posts/raspberrypi-4b-arch/","title":"在树莓派 4B 上安装 Arch Linux ARM"},{"content":"前言 在 GitHub 上浏览许多大仓库时，常常能见到在 commit 信息旁边有一个绿色的标识，里面写着 Verified。这种一看就令人安心的标志，自己也想搞一个（）上网查了查资料，发现只要对提交到 GitHub 的 commit 使用 GPG 进行签名即可，步骤也不麻烦，遂进行一个记录。\n什么是 GPG GnuPG is a complete and free implementation of the OpenPGP standard as defined by RFC4880 (also known as PGP). GnuPG allows you to encrypt and sign your data and communications; it features a versatile key management system, along with access modules for all kinds of public key directories. GnuPG, also known as GPG, is a command line tool with features for easy integration with other applications. A wealth of frontend applications and libraries are available. GnuPG also provides support for S/MIME and Secure Shell (ssh).\n摘自 GPG 官网\n简单来说，GPG (GNU Privacy Guard) 是由 GNU 组织提供的一款加密工具，并且是目前世界上最好用的加密工具之一。GPG 的用途十分广泛，而我们今天只是用它进行 git commit 的签名认证。\n生成 GPG Key Windows 下安装 Git Bash 已经自带了 GPG 工具，可以使用 gpg --version 验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026gt; gpg --version gpg (GnuPG) 2.2.29-unknown libgcrypt 1.9.3-unknown Copyright (C) 2021 Free Software Foundation, Inc. License GNU GPL-3.0-or-later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Home: /c/Users/b1acksoil/.gnupg Supported algorithms: Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256 Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224 Compression: Uncompressed, ZIP, ZLIB, BZIP2 接着我们生成一个新的 GPG key：\n1 \u0026gt; gpg --full-generate-key 提示输入算法类型，密钥长度，选择默认即可。然后输入自己的邮箱、名称和密钥备注，最后会弹出一个窗口让你设置密码。\n生成好密钥后会将密钥的 ID 输出在屏幕上，忘记了也没关系，可以使用 gpg --list-keys 查看。\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt; gpg --list-keys gpg: checking the trustdb gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: depth: 0 valid: 1 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 1u /c/Users/b1acksoil/.gnupg/pubring.kbx ------------------------------------- pub rsa3072 2022-10-01 [SC] 114514191981011451419198101145141919810 uid [ultimate] b1acksoil (for git commit) \u0026lt;dev@sorabs.cc\u0026gt; sub rsa3072 2022-10-01 [E] pub 一栏，在密钥算法和日期下面，就是我们的密钥 ID。\n使用 GPG 对 git commit 签名 在对 git commit 进行签名之前，我们需要配置一下 git，让它知道我们使用了这个新创建的 GPG 密钥签名 commit：\n1 $ git config --global user.signingkey 你的密钥ID 为了试试签名的效果，我们随便创建一个测试用的 git 仓库，并进行一次提交：\n1 2 3 4 5 $ mkdir testgpg $ cd testgpg $ touch abc.txt $ git add . $ git commit -m -S \u0026#34;test gpg key\u0026#34; 这里提交时的 -S 选项，表示我们使用 GPG 签名这次提交。\n不同于以往直接提交成功，git 弹出一个窗口要求你输入密码，也就是我们设置的密钥密码。正确输入后便会完成提交，也就完成了我们第一次由 GPG 验证过的 commit。\n不想每次都输入 -S 选项？ 可以配置 git config --global commit.gpgsign true，这样每一次提交都会自动签名。 将密钥导入 GitHub 本地签名好了，我们需要在 GitHub 里添加我们的密钥，否则即使签名了 GitHub 不认，也就没有小绿标了。\n首先查看我们的 GPG 公钥：\n1 2 3 4 5 6 7 \u0026gt; gpg --armor --export 你的密钥ID -----BEGIN PGP PUBLIC KEY BLOCK----- （你的公钥） -----END PGP PUBLIC KEY BLOCK----- 登录 GitHub，点击头像 - Settings，然后打开 SSH and GPG keys 选项卡。\n点击 New GPG key，输入想要的名称，然后把上面获取的公钥完整地（包括 -----BEGIN PGP PUBLIC KEY BLOCK----- 和 -----END PGP PUBLIC KEY BLOCK-----）复制到下面的文本框内，然后点击 Add GPG key 按钮完成。\n这时我们就成功地让 GitHub “认识” 了我们的密钥了。本地执行一个提交并 push 到 GitHub 上，你会看到提交信息旁边有一个闪亮的 Verified 标识。\n附加：信任 GitHub 的 GPG 公钥 虽然我们本地的 commit 已经是签名过的了，但不在本地的，例如直接在 GitHub 网页端执行的提交，则是由 GitHub 代为签名，这导致我们无法验证这些签名的真实性。\n信任 GitHub 的公钥即可解决这个问题：\n1 $ curl https://github.com/web-flow.gpg | gpg --import 回车执行，提示：\n1 gpg: key 4AEE18F83AFDEB23: public key \u0026#34;GitHub (web-flow commit signing) \u0026lt;noreply@github.com\u0026gt;\u0026#34; imported 这里的 4AEE18F83AFDEB23 （可能有变化，以实际情况为准）就是 GitHub 的公钥 ID。接下来使用自己的密钥为其签名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ gpg --sign-key 4AEE18F83AFDEB23 pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: full [ full ] (1). GitHub (web-flow commit signing) \u0026lt;noreply@github.com\u0026gt; pub rsa2048/4AEE18F83AFDEB23 created: 2017-08-16 expires: never usage: SC trust: unknown validity: full Primary key fingerprint: 5DE3 E050 9C47 EA3C F04A 42D3 4AEE 18F8 3AFD EB23 GitHub (web-flow commit signing) \u0026lt;noreply@github.com\u0026gt; Are you sure that you want to sign this key with your key? Really sign? (y/N) y 输入 y 并回车确认，我们便可以看到所有的签名都得到了验证。\n","date":"2022-10-01T15:52:24+08:00","image":"https://sorabs.cc/posts/sign-git-commit-with-gpg/cover_huf80b4d0831747132b718fc35d3089796_53637_120x120_fill_q75_box_smart1.jpg","permalink":"https://sorabs.cc/posts/sign-git-commit-with-gpg/","title":"使用 GPG 签名你的 Git Commit"},{"content":"最近入了 Arch Linux 的坑，手上没有空闲的机子可以装着玩，虚拟机又有点膈应的感觉，就找了找资料在 WSL2 上装了体验一下。\n关于 WSL1 和 WSL2 的区别，不在本文的讨论范围内，可以前往微软的官方说明查看。\n本文中，以 \u0026gt; 开头的命令为 Powershell 命令，# 开头为 Arch 中的 root 用户命令，$ 开头为 Arch 中的普通用户命令。\n准备工作 Windows 10 2004 版本或以上（我使用的是 Windows 11） 可选功能中打开适用于 Linux 的 Windows 子系统和虚拟机平台 首先前往 这里 下载 WSL 的内核更新包，不然没法安装。\n安装后将 WSL 的默认版本设置为 WSL2：\n1 \u0026gt; wsl --set-default-version 2 安装 Arch 前往 项目仓库 (yuk7/ArchWSL) 的 Releases 页面下载最新的 Arch.zip，并解压到具有写权限的空文件夹里。留意 Arch.exe 的名称，.exe 前的部分会作为稍后在 WSL 内注册的发行版名称，例如改名成 ArchLinux.exe，稍后的实例就叫 ArchLinux。\n多个 Arch 共存 由于这里的 Arch 是通过文件安装，只要将 exe 文件复制并改名即可。注意改名后的文件不要和已有的实例名称重复。 双击打开 Arch.exe，程序会自动注册 rootfs 和注册表配置。\n创建默认用户 直接使用 root 用户很不安全，这里我们创建一个新的用户代替 root 进行日常使用。\n1 # useradd -m -G wheel -s /bin/bash bs 这里的 bs 是用户名称，将其换成你自己的。然后为新用户设置密码：\n1 # passwd bs 为了使新用户可以使用 sudo 权限，编辑 /etc/sudoers 文件，找到 root ALL=(ALL:ALL) ALL，在其下添加一行 bs ALL=(ALL:ALL) ALL （bs 同样换成刚刚的用户名）；并找到 #%wheel ALL=(ALL:ALL) ALL，将其取消注释（去掉最前面的 #）\n找不到编辑器 如果没有自己常用的编辑器（如 vim），可以先跳到下面的 Pacman 配置小节，然后自行安装。 改好了是这样的：\n1 2 3 4 root ALL=(ALL:ALL) ALL bs ALL=(ALL:ALL) ALL %wheel ALL=(ALL:ALL) ALL 然后使用 exit 退出 Arch 交互界面，打开 Powershell，切换到 Arch 目录，输入以下命令将默认登录用户切换为刚刚创建的新用户：\n1 \u0026gt; Arch.exe config --default-user bs 配置 Pacman 打开 Arch.exe 进入命令行。\n由于众所周知的原因，国内访问 Arch 的软件源十分缓慢，这里将源换为清华大学开源镜像站的源。\n编辑 /etc/pacman.d/mirrorlist，往下翻找到 China 一栏，将 https://mirrors.tuna.tsinghua.edu.cn 行取消注释。也可以多取消几个注释作为后备。如果懒得找也可以直接在文件开头添加：\n1 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 初始化 Pacman 的密钥环：\n未创建新用户 如果刚刚没有创建用来代替 root 的新用户，请将本节命令中的 sudo 去除， 1 2 3 $ sudo pacman-key --init $ sudo pacman-key --populate $ sudo pacman -Syy archlinux-keyring 执行滚动更新：\n1 $ sudo pacman -Syu 搭建完成 这样就配置好了一个基本的 Arch Linux 环境了，但仍然是一个空壳子，接下来给它配置一些常用服务。 安装包管理器 yay yay 是一个广泛使用的 AUR Helper，解决了 pacman 无法安装 AUR 软件的问题，同时完全兼容 pacman 操作。\n首先安装必要软件包：\n1 $ sudo pacman -S base-devel git 安装 yay-bin（如果直接安装 yay 则需要自己编译）：\n1 2 3 4 5 $ cd ~ $ git clone https://aur.archlinux.org/yay-bin.git $ cd yay-bin $ makepkg -si $ yay 安装 oh-my-zsh oh-my-zsh 是一个常用的 zsh 框架，提供了许多美观的主题和实用插件，能极大提升 shell 下的效率。\n1 2 $ yay -S zsh curl $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 安装基本插件，这里我安装了自己常用的 zsh-autosuggestions 和 zsh-syntax-highlighting 来提供自动补全和语法高亮。\n1 2 3 $ cd ~/.oh-my-zsh/plugins $ git clone https://github.com/zsh-users/zsh-autosuggestions.git --depth 1 $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git --depth 1 编辑 ~/.zshrc，找到 plugins，在 git 后面添加插件名称，使用空格或空行分隔。也可以往上找到 ZSH_THEME 并修改主题。\n","date":"2022-10-01T09:38:08+08:00","image":"https://sorabs.cc/posts/wsl2-arch/cover_hu33e4827e4f1cec4102b61099883c8097_54721_120x120_fill_q75_box_smart1.jpg","permalink":"https://sorabs.cc/posts/wsl2-arch/","title":"使用 WSL2 部署 Arch Linux 环境"},{"content":"起因 经常需要在电脑和手机之间互传文件，想了不少办法，最早是使用 QQ 等聊天工具进行文件传输，效率十分低下；后来找到了 SnapDrop 这款工具，可以以类似面对面快传的方式在局域网内传输文件，提高了些许效率，但还是感觉到些许别扭。于是开始找寻一种更为优雅的文件传输方式，想到手里有一个半吃灰的树莓派，就开始着手搭建自己的 FTP 文件服务器。\n什么是 FTP 文件传输协议（File Transfer Protocol，缩写 FTP）是一个用于在计算机网络上在客户端和服务器之间进行文件传输的应用层协议。 相比 WebDav 等其他传输协议，纯 FTP 的安全性略显低下，但对于小型自用而言已经绰绰有余。\n搭建 关于树莓派 本文中使用的树莓派信息如下：\n型号：4B\nRAM：4GB\n系统：Ubuntu Server 22.04 首先安装软件包 vsftpd\n1 $ sudo apt install vsftpd -y 安装过程中会自动创建一个名为 ftp 的用户，我们给它设置一个密码作为稍后的登录密码（若打算开启匿名登录可跳过）：\n1 $ sudo passwd ftp FTP 文件存放位置 FTP 服务开启后的文件存储位置就是 frp 用户的家目录，位于 /srv/ftp 密码更改完成后，选用喜欢的编辑器打开 FTP 服务器配置文件 /etc/vsftpd.conf，按照需求取消注释（去掉行首的 # 号）或修改相应选项（如果找不到被注释的选项在哪里也可以直接在文件末尾添加，格式为 选项=值）。这里列出几个常用的，YES/NO 分别对应是/否：\n通用\nlocal_enable：是否允许本地用户登录\nwrite_enable：是否允许写入操作（上传文件、新建文件夹等）\nutf8_filesystem：启用 UTF-8 支持\n匿名登录相关\nanonymous_enable：是否允许匿名登录\nanon_upload_enable：是否允许匿名用户上传文件\nanon_mkdir_write_enable：是否允许匿名用户新建文件夹\nChroot 相关\nchroot_local_user：是否将连接 FTP 的本地用户的根目录限制为其家目录（/home/\u0026lt;username\u0026gt;）\nchroot_list_enable：启用 chroot 白名单，只有在其中的用户才会被 chroot（如果把 chroot_local_user 设置为 YES 将变为黑名单，只有在其中的用户不会被 chroot）\nchroot_list_file：chroot 黑/白名单的文件路径，文件中填写用户名，一行一个\n注：如果只设置 chroot_local_user 为 YES 而不设置黑/白名单，会对所有连接 FTP 的本地用户进行 chroot。\n修改好配置后重启 FTP 服务：\n1 $ sudo systemctl restart vsftpd 连接 查看树莓派 IP，可以使用 ip addr 或 ifconfig 等等方式。这里举例为 192.168.0.114，后续命令中记得替换成自己的。\n使用 FTP 工具进行连接测试，这里先使用 Linux 和 Windows 都自带的 ftp 命令：\n1 $ ftp 192.168.0.114 提示输入用户名和密码，用户名输入 ftp，密码输入之前设置的密码，若设置了匿名就直接留空回车。\n1 2 3 4 5 6 7 Connected to 192.168.0.114. 220 (vsFTPd 3.0.5) Name (192.168.0.114:bs): ftp 331 Please specify the password. Password: 230 Login successful. ftp\u0026gt; 成功进入 FTP Shell 后可以输入 ls，pwd 等命令进行测试，使用 quit 退出。\n搭建完成 一个简单的 FTP 服务器已经搭建完毕，可以使用各种 FTP 工具连接使用。\n如果搭建过程中遇到问题，可以参考文章后面的问题解决部分。\n体验 搭建完成后，我分别使用移动端的 MT 管理器、和 Windows 自带的网络位置进行了测试。在 MT 管理器下连接后操作十分流畅，上传/下载的速度也很快。而 Windows 自带的网络位置则十分难用，打开文件只打开了一个空的 Edge，复制文件十分缓慢，新建文件夹需要延迟很久，删除文件也经常删不掉。fkms\n但尽管如此，通过 FTP 传输文件仍然带来了一种全新的体验：手机上将文件移进”文件夹“，转眼就能在电脑上移出来使用，做到了几近原生、无缝的传输体验。相信如果解决了 Windows 端的工具问题，效率会大大提升。\n问题解决 无法登录进 FTP Shell Ubuntu 官网的说明 To allow users with a shell of /usr/sbin/nologin access to FTP, but have no shell access, edit /etc/shells adding the nologin shell.\nThis is necessary because, by default vsftpd uses PAM for authentication, and the /etc/pam.d/vsftpd configuration file contains:\nauth required pam_shells.so\nThe shells PAM module restricts access to shells listed in the /etc/shells file.\n摘自这里\n解决办法：编辑 /etc/shells，在文件末尾添加一行 /usr/sbin/nologin\n550 create directory operation failed 如果设置了 write_enable 后仍不能创建文件夹，需要确保根目录具有可执行权限。执行以下命令：\n1 $ chmod 777 -R /srv/ftp vsftpd: refusing to run with writable root inside chroot 如果设置了 chroot 后无法新建文件夹/上传文件，并提示以上信息，是因为 2.3.5 版本后 vsftpd 加强了安全检查，用户的主目录不能再有写权限，如果检查到就会报错。可以在配置文件中添加 allow_writeable_chroot=YES 来解决。\n参考自这里\n","date":"2022-09-14T20:34:14+08:00","image":"https://sorabs.cc/posts/raspberrypi-ftp-server/cover_hu9e7cb5a45df0cdaf3fb81de0a36b0a5e_155771_120x120_fill_q75_box_smart1.jpg","permalink":"https://sorabs.cc/posts/raspberrypi-ftp-server/","title":"树莓派搭建 FTP 服务器实现局域网文件共享"},{"content":"Typography 隐藏文字，鼠标悬停（移动端点击）以展示： HUGO YES!\nShortcodes Tip Information Information tip test. Note Note tip test. Warning Warning tip test. Error Error tip test. Success Success tip test. Quote Quote tip test. Example Example tip test. 这是一段长文本 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ","date":"2022-09-13T21:25:32+08:00","image":"https://sorabs.cc/posts/testground/cover_huc792f4b39d5c3e81ac227f21be32ba93_31697_120x120_fill_box_smart1_3.png","permalink":"https://sorabs.cc/posts/testground/","title":"测试场 | TestGround"},{"content":"一直听说星露谷对于 Mod 的支持十分完善，这次打算自己尝试一番。\n注意 本文仅针对 Windows 平台，其他平台方法大同小异，可以直接参照官方 Wiki。 首先到 SMAPI 官网下载最新的安装包，可以选择从 NexusMods (N 网) 下载，也可以直接下载 (Direct download)。截至本文，SMAPI 的最新版本为 3.16.2。\n把下载下来的 SMAPI-\u0026lt;版本\u0026gt;-installer.zip 解压到任意位置，打开里面的 install on Windows.bat，安装脚本会自动检测游戏的安装位置。如果没有找到会提示以下信息：\n1 2 3 Oops, couldn\u0026#39;t find the game automatically. Type the file path to the game directory (the one containing \u0026#39;Stardew Valley.dll\u0026#39;), then press enter. 出现这种情况，首先找到星露谷的安装目录，若为 Steam 安装可以直接右键库里的星露谷，选择管理 - 浏览本地文件，然后复制打开的文件夹路径（例如我的是 D:\\Steam\\steamapps\\common\\Stardew Valley），再粘贴进终端内并回车。\n1 2 3 4 5 6 What do you want to do? [1] Install SMAPI. [2] Uninstall SMAPI. Type 1 or 2, then press enter. 输入 1 并回车继续安装。日后如果想要卸载 SMAPI，可以再次运行此脚本并选择 2 卸载。\n如果出现以下信息，则为安装成功：\n1 2 3 4 SMAPI is installed! If you use Steam, set your launch options to enable achievements (see smapi.io/install): \u0026#34;D:\\Steam\\steamapps\\common\\Stardew Valley\\StardewModdingAPI.exe\u0026#34; %command% If you don\u0026#39;t use Steam, launch StardewModdingAPI.exe in your game folder to play with mods. 提示信息中指出，如果使用 Steam 启动游戏，可以设置启动项来确保安装 SMAPI 后也能正常获得成就。\n注意 在配置Steam启动项之前，需要确保您的游戏路径里没有中文，否则将设置失败。 首先复制终端窗口中给出的启动指令（如上文，为 \u0026quot;D:\\Steam\\steamapps\\common\\Stardew Valley\\StardewModdingAPI.exe\u0026quot; %command%），Steam 中右键星露谷打开属性，在“通用”选项卡中把复制的指令粘贴进“启动选项”一栏，保存即可。\n至此已经完成了 SMAPI 的安装，至于添加 Mod 下次再讲 （咕咕咕（（\n","date":"2022-09-13T19:34:50+08:00","permalink":"https://sorabs.cc/posts/smapi-install/","title":"星露谷模组加载器 —— SMAPI 的安装"},{"content":"很久没写博客了，前些天看到几个群友的博客，心血来潮想把自己的复兴一下\n发展历程 在此前已经有过两版博客，但由于懒惰等原因（）现在都废弃了。\nv1 - Hexo 最早的一版基于 Hexo 搭建，主题使用自定义程度极高的 butterfly，也草草写过几篇文章。但也正因为自定义程度极高，导致花费大量时间去折腾，反而丢了写博客的初衷。而且 butterfly 主题引用大量的 js 文件和各种图片资源，博客变得非常臃肿，再加上 GitHub Pages 的网络因素，加载非常耗时，不久就放弃了。\nv2 - Vue 沉寂一段时间之后突然心痒痒，又打算重做一个博客。这时候已经学过了 Vue.js，就抛弃了原有的 Hexo 架构，为了追求极致的开始自己从头写起。最终成品为单页面应用，同时使用自己写的 CLI 工具管理文章、图片等资源。但 v1 时 butterfly 的自定义就花费大量精力了，自己写指挥更甚。再者单页面应用对于 SEO 优化不是友好，也没有多余的服务器搞服务端渲染，加上技术不到位导致成品各种瑕疵\u0026hellip;多方面因素之下，第二版也放弃了。\nv3 - Hugo! 又隔了很久，直到最近才打算把博客重新搭起来，不然有时的一些想法也没法记录。参考了上次的教训，这次依然是在已有的博客框架中选择。寻觅一番后，最终选择了 Hugo。Hugo 与 Hexo 类似，同为静态网站生成引擎。但 Hexo 使用 Node.js 编写，而 Hugo 使用 Go，性能远远超过前者。（写到这里的时候测试了一下，执行生成操作的耗时仅有 1262ms，而印象中以前 Hexo 需要数十秒）；而且得益于 Go 语言的特性，Hugo 的所有环境只有一个简单的可执行文件，比起 Hexo 麻烦的环境配置好上太多。\n总结 从几版的经验可以看出，次次都在舍本逐末，钻研各种配置，却忘记了写文章的初衷。希望这一次的 v3 可以让自己反思一下，坚持下去。\n","date":"2022-09-12T15:44:45+08:00","permalink":"https://sorabs.cc/posts/brand-new-blog-v3/","title":"Brand New Blog v3"},{"content":"最近学 2D 游戏开发，想自己画点像素画，就去找了找有什么好用的像素画软件。首先就想到了大名鼎鼎的 Aseprite，去 Steam 上搜了下，70RMB。\n对于穷学生党来说 70 也不少了（）何况我年初收了一台米板 2，目前处于囊中羞涩的状态。搜索一番发现 Aseprite 居然是在 GitHub 上开源的，官方 repo 里也提供了编译说明，遂自行编译之。\n本文仅涉及 Windows 平台下的编译，若是 macOS 或是 Linux 平台可自行查看官方编译说明（方法大同小异，甚至更简单，因为不用装 VS）\n平台：Windows 10\n准备工作 安装 Visual Studio 2019+ Windows 下的编译需要用到 Visual Studio Community （微软的 IDE）的 2019 或以上的版本，我使用的是 VS2022\n前往 Visual Studio Downloads 下载社区版\n下载完成打开安装程序，选择 “使用 C++ 的桌面开发”，并在右侧至少勾选 “MSVC C++ x64/x86 生成工具” 和 “Windows 10 SDK”，然后点击安装。\n安装 Cmake 前往 Cmake 官网，在下方的 Binary distributions 中找到最新的 msi 安装文件并下载。\n安装时选择第二个或者第三个就不用自己配置环境变量：\n记下 Cmake 的安装目录，稍后会用到。\n关于 MinGW Aseprite 编译不支持 MinGW，所以对于 MinGW 用户，需要将环境变量中的 MinGW 删除。 安装 Ninja 前往 Ninja Releases 下载 ninja-win.zip\n打开 Cmake 的安装目录，并把 ninja-win.zip 中的 ninja.exe 解压到 \u0026lt;Cmake安装目录\u0026gt;\\bin 下\n下载 Skia-m96 前往 Skia Releases 根据系统位数下载 Skia-Windows-Release.zip，我的系统是 64 位的所以下载 x64 版本。 注意下载的是 m96 版本，不要下错了。\n下载完解压好，记下位置，放在一旁备用。\n编译 Aseprite 下载 Aseprite 源码 前往 Aseprite Releases 下载 Aseprite-\u0026lt;version\u0026gt;-Source.zip 并解压，会使用 git 的也可以直接克隆仓库 https://github.com/aseprite/aseprite.git\n开始编译 在开始菜单的 Visual Studio 文件夹里找到 x64 Native Tools Command Prompt for VS（32 位打开 x86）\n初始化完成后输入 cd \u0026lt;Aseprite源码目录\u0026gt; 切换到源码目录下，如果在另一个分区则需要先用 \u0026lt;盘符\u0026gt;: 切换。如默认打开了 D:\\Microsoft Visual Studio\\2022\\Community，而我的源码在 C:\\Users\\b1acksoil\\Downloads\\Aseprite-Source 里：\n1 2 C: cd C:\\Users\\b1acksoil\\Downloads\\Aseprite-Source 依次输入以下命令，第三条命令中将尖括号的内容（包括尖括号）替换为刚刚下载 Skia 解压后的文件夹：\n1 2 3 mkdir build cd build cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLAF_BACKEND=skia -DSKIA_DIR=\u0026#34;\u0026lt;Skia目录\u0026gt;\u0026#34; -DSKIA_LIBRARY_DIR=\u0026#34;\u0026lt;Skia目录\u0026gt;\\out\\Release-x64\u0026#34; -DSKIA_LIBRARY=\u0026#34;\u0026lt;Skia目录\u0026gt;\\out\\Release-x64\\skia.lib\u0026#34; -G Ninja .. 随后等待第一段编译，时间取决于你的电脑性能。结束后输入：\n1 ninja aseprite 期间最好不要做其他事情，性能差的电脑可以把后台清一清，否则可能会卡到一半。可以开个任务管理器看看，编译很占 CPU，如果 CPU 占用突然下去了并且命令行长时间不动了，就是卡住了，使用 Ctrl+C 终止，输入 cd ..，删除 Aseprite 源码下的 build 文件夹再重试一次。\n完成后可以在 Aseprite 源码下的 build 文件夹内找到 bin 文件夹，可以重命名并移动到其他地方，里面的 aseprite.exe 就是编译好的 Aseprite 主程序了。此时可以右键 aseprite.exe，并 发送到 \u0026gt; 桌面快捷方式。\n汉化（可选） Aseprite 默认不含中文，但可以使用社区自制的中文汉化包。可以前往 README 查看并下载。\n更新 如果 Aseprite 有更新，手动编译相比直接在 Steam 购买还是有一些缺陷的，只能重新编译。下载新版的源码，按照上面流程再来一遍即可，麻烦是麻烦了点，但是可以白嫖还要什么自行车呢（\n","date":"2022-02-09T19:00:12+08:00","image":"https://sorabs.cc/posts/manually-compile-aseprite/cover_hu33e4827e4f1cec4102b61099883c8097_67249_120x120_fill_q75_box_smart1.jpg","permalink":"https://sorabs.cc/posts/manually-compile-aseprite/","title":"手动编译像素画软件 Aseprite"},{"content":"前些天把树莓派 4B 的系统换成了 Ubuntu Desktop 21.04，使用没什么问题，驱动支持也非常好，遂美化之。\n本教程适用于任何 Ubuntu Desktop 系统（18.04 及以上），不仅限于树莓派。\n先看看美化前的效果：\n再看看美化后：\n准备工作 一台安装了 Ubuntu Desktop 系统（18.04 版本及以上）的设备 手 使用前请将软件源更新到最新版本：\n1 $ sudo apt update 安装美化管理工具 打开终端，安装 gnome-tweaks 工具\n1 $ sudo apt install gnome-tweaks chrome-gnome-shell -y 随后打开 https://extensions.gnome.org/ ，点击 Click here to install browser extension 安装浏览器插件\n随后搜索 User Themes 插件安装，点击页面右上角的开关，把OFF改成ON就可以了，如果弹出确认窗口就点确认\nDock 栏 Ubuntu Desktop 自带的 Dock 栏并不是很好用，可定制性也不强，这里使用 Dash to Dock 插件增强。\n向上面安装 User Theme 插件一样，在 https://extensions.gnome.org/ 中搜索 Dash to Dock 并安装。\n然后去 Gnome Tweaks 里启用：\n随后你可以右键 Dock 栏上的应用抽屉图标，打开 Dash to Dock 设置，这里可以配置一系列设置，如位置、图标大小、透明度等等。\nMac 风格主题安装 文首那种 Mac 风格的美化包是 WhiteSur-gtk-theme。\n作者建议使用脚本方式安装，这样可以体验主题的全部功能，例如锁屏美化，Dock 栏美化等等。方法如下：\n确保你安装了 git：\n1 $ sudo apt install git -y 将 GitHub 上的源码仓库克隆到本地：\n1 $ git clone https://github.com/vinceliuice/WhiteSur-gtk-theme.git 执行安装：\n1 2 3 $ cd WhiteSur-gtk-theme $ chmod +x ./install.sh # 赋予可执行权限 $ ./install.sh 这会以默认的方式自动安装 WhiteSur 主题到系统。（同时安装亮/暗色，所有选项保持默认）\n自定义安装 基本配置 这里列出了基本的主题配置选项\n主题模式 使用 -c 或 --color 选项选择主题模式（亮/暗色），可以重复使用\n1 2 $ ./install.sh -c light # 只安装亮色 $ ./install.sh -c light -c dark # 亮暗色一起安装 默认：亮暗色一起安装\n主题色 使用 -t 或 --theme 选项选择主题色，可以重复使用\n1 2 3 $ ./install.sh -t red # 只安装红色 $ ./install.sh -t red -t blue # 安装红色和蓝色 $ ./install.sh -t all # 安装所有 默认：安装 default 颜色\n文件管理侧边栏宽度 使用 -s 或 --sidebar 选项更改文件管理的侧边栏宽度\n1 $ ./install.sh -s 220 默认：使用 default 宽度\n活动窗口管理器图标 使用 -i 或 --icon 选项更改活动窗口管理器的图标（最左上角的那个）\n1 $ ./install.sh -i ubuntu 默认：使用苹果 logo\n文件管理器样式 使用 -N 或 --nautilus-style 选项更改文件管理器的样式\n1 $ ./install.sh -N mojave 默认：default 样式\n进阶配置 这里列出了一些进阶配置，如 Firefox 浏览器美化，锁屏美化，Dash to Dock 美化等等\n需要用到 ./tweaks.sh，先赋予可执行权限：\n1 $ chmod +x ./tweaks.sh Firefox 火狐浏览器 使用 -f 或 --firefox 选项更改 Firefox（火狐浏览器）的界面样式\n1 2 $ ./tweaks.sh -f # 使用默认样式 $ ./tweaks.sh -f monterey # 使用 Monterey 样式 Dash to Dock 使用 -d 或 --dash-to-dock 选项更改 Dash to Dock 的样式\n1 2 $ ./tweaks.sh -d # 根据主题选择 $ ./tweaks.sh -d -c dark # 使用暗色 锁屏样式 使用 -g 或 --gdm 选项更改 Dash to Dock 的样式，需要以 root 身份运行。 -b、-n、-N 选项可以搭配使用。\n1 2 3 4 5 6 $ sudo ./tweaks.sh -g # 安装锁屏样式 $ sudo ./tweaks.sh -g -b \u0026#34;your picture.jpg\u0026#34; # 自定义锁屏壁纸 $ sudo ./tweaks.sh -g -b default # 使用默认锁屏壁纸 $ sudo ./tweaks.sh -g -b blank # 不使用壁纸 $ sudo ./tweaks.sh -g -n # 不模糊壁纸 $ sudo ./tweaks.sh -g -N # 不调暗壁纸 更多选项可以输入 ./tweaks.sh -h 来查看。\n图标 图标也可以使用 WhiteSur 的，来自于同一个作者。\n安装 与主题本体类似，需要使用 git 将仓库克隆到本地：\n1 2 3 4 $ git clone https://github.com/vinceliuice/WhiteSur-icon-theme.git $ cd WhiteSur-icon-theme $ chmod +x ./install.sh $ ./install.sh 下面列出了一些可用选项：\n-d, --dest 定制主题安装目录 （默认为 $HOME/.themes） -n, --name 定制图标主题名 （默认为 WhiteSur） -t, --theme 定制主题色 [default/purple/pink/red/orange/yellow/green/grey/all] （默认为蓝色） -a, --alternative 为软件中心和文件管理器安装图标 -b, --bold 安装加粗版本（推荐在高分屏下使用） --black 安装黑色面板主题图标 -h, --help 显示帮助信息 应用主题 有时主题不会自动应用至系统，这时需要手动打开一开始安装的美化管理工具。应用列表里找到 优化 应用或者终端输入 gnome-tweaks\n都选择 WhiteSur 即可。如果配置后不生效，重启后即可看到效果。\n参考 WhiteSur-gtk-theme GitHub 仓库 ","date":"2021-07-27T23:25:10+08:00","image":"https://sorabs.cc/posts/ubuntu-desktop-mac-style/cover_hu57b1fac583eb5e56d9ebcd616bc65806_81861_120x120_fill_q75_box_smart1.jpg","permalink":"https://sorabs.cc/posts/ubuntu-desktop-mac-style/","title":"Mac风格 Ubuntu Desktop 美化教程"}]